---
description: 
globs: 
alwaysApply: false
---
## React Component Structure Rules

### 0. Naming
- Components: PascalCase (`UserProfile.tsx`)
- ts files: camelCase (`useGetIcon.ts`)
- Folders: kebab-case (`user-profile`)
- Props: camelCase (`userName`)
- Event handlers: camelCase with 'handle' prefix (`handleUserSelected`)
- Custom hooks: camelCase with 'use' prefix (`useUserData`)

### 1. File Structure

- Always use functional components with TypeScript and hooks.
- Export the component as a named export.
- Define the component's PropTypes interface before the component definition.
- Place the export statement at the end of the file.

### 2. Inside the Component File

**Import Order:**
1. Import React and React hooks first.
2. Import TypeScript interfaces and types (`interface`, `type`).
3. Import Redux selectors and actions.
4. Import custom hooks (e.g., `useYourHook`).
5. Import router hooks (e.g., `useNavigate`, `useParams`).
6. Import libraries and third-party dependencies.
7. Import local components.
8. Import styles or CSS modules (if not using Tailwind exclusively).

**Important:**  
- Always import React hooks directly from React (such as `useState`, `useEffect`, etc.).
- Create custom hooks for reusable logic and keep component code clean.

**Loading State Rule:**
- For implementing loading state (`isLoading`) in a component, use the global state from Redux store (via the `useSelector` hook) instead of creating a new local state. This ensures unified loading state management across the entire application.

**Next, in the component definition:**
1. Define the Props interface.
2. Initialize hooks at the top of the component function.
3. Initialize state using `useState`.
4. Initialize refs using `useRef`.
5. Initialize selectors with `useSelector`.
6. Initialize dispatch with `useDispatch`.
7. Define derived states with `useMemo`.
8. Define callback functions with `useCallback`.
9. Define event handlers.
10. Define side effects with `useEffect` (grouped by related functionality).
11. Return the JSX.

---

### Example Structure

```tsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useParams, useNavigate } from 'react-router-dom';

// Import types
import type { MyType } from '../types';

// Import Redux selectors and actions
import { selectData, fetchData } from '../store/dataSlice';
import { selectIsLoading } from '../store/generalSlice'; // Use global isLoading state

// Import custom hooks
import { useCustomHook } from '../hooks/useCustomHook';

// Import libraries
import _ from 'lodash';

// Import components
import MyComponent from '../components/MyComponent';

// Define Props interface
interface UserProfileProps {
  userId: string;
  onUserUpdate?: (user: MyType) => void;
}

export const UserProfile: React.FC<UserProfileProps> = ({ userId, onUserUpdate }) => {
  // Initialize hooks
  const params = useParams();
  const navigate = useNavigate();
  const dispatch = useDispatch();
  
  // Initialize state
  const [count, setCount] = useState(0);
  
  // Initialize refs
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Initialize selectors
  const data = useSelector(selectData);
  const isLoading = useSelector(selectIsLoading); // Use global loading state
  
  // Derived state
  const double = useMemo(() => count * 2, [count]);
  
  // Callback functions
  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []);
  
  // Event handlers
  const handleUserClick = () => {
    if (onUserUpdate && data) {
      onUserUpdate(data);
    }
  };
  
  // Side effects - grouped by related functionality
  useEffect(() => {
    // Data fetching effect
    dispatch(fetchData(userId));
  }, [userId, dispatch]);
  
  useEffect(() => {
    // Count change effect
    if (count > 10) {
      navigate('/limit-reached');
    }
  }, [count, navigate]);
  
  // Return JSX
  return (
    <div ref={containerRef}>
      {isLoading ? (
        <p>Loading...</p>
      ) : (
        <>
          <h1>User Profile</h1>
          <p>Count: {count}</p>
          <p>Double: {double}</p>
          <button onClick={increment}>Increment</button>
          <button onClick={handleUserClick}>Update User</button>
          <MyComponent data={data} />
        </>
      )}
    </div>
  );
};

export default UserProfile;
```

---

**Custom Hook Structure**

```tsx
import { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

// Define return type for the hook
interface UseCustomHookResult {
  data: any;
  isLoading: boolean;
  error: string | null;
}

export const useCustomHook = (id: string): UseCustomHookResult => {
  // State
  const [error, setError] = useState<string | null>(null);
  
  // Redux
  const dispatch = useDispatch();
  const data = useSelector(state => state.someFeature.data);
  const isLoading = useSelector(state => state.general.isLoading);
  
  // Effects
  useEffect(() => {
    // Implementation
  }, [id, dispatch]);
  
  return { data, isLoading, error };
};
```

**Follow this order for clean, readable, and maintainable React code.**